# Mocking dependencies in Go
[原文地址（https://medium.com/agrea-technogies/mocking-dependencies-in-go-bb9739fef008）](https://medium.com/agrea-technogies/mocking-dependencies-in-go-bb9739fef008)
## 概括
当我们在写一个程序的时候我们经常会用到很多框架，包括内部开发的框架和一些第三方的框架。我会在接下来为大家介绍[`mockery`](https://github.com/vektra/mockery)和[`stretchr/testify/mock`](https://github.com/stretchr/testify/tree/master/mock)这两个框架，让大家能更简单的进行单元测试的mock
## 让我们更加深入：举个例子
当我们为自己的代码写单元测试的时候，我们可能会发现外部的代码导入的错误。考虑这种情况：
```golang
import "github.com/mediocregopher/radix.v2/redis"
type Handler struct {
    db *redis.Client
}
func (h *Handler) Ping() (string, error) {
    res := h.db.Cmd("INCR", "ping:count")
    if res.Err != nil {
        return "", res.Err
    }
    return "pong", nil
}
```
我们定义了一个struct为`Handler`,其中包含Redis client变量。其中在`Handler`中有一个`Ping`方法，它依赖于Redis client的接口。现在当我们为`Ping`做单元测试的时候，我们想要确认两件事：
+ 什么时候Redis会抛出或者不抛出error
+ 什么时候会返回正确或者不正确的字符串

这些时候我们需要有一个真正的的Redis数据库为了去调用`Cmd`命令。然而当我们为了测试`Ping`方法时，我们不应该依赖于一个真实的Redis。我们真正关心的是`Ping`方法本身和在某些特定的情况下`Ping`方法的运行情况。
### 解决方法：构造一个接口
我们可以看出`db`是通过`*redis.Client`工作的，我们可以看出它是一个指针指向一个*struct*，mock *struct*是很困难的，我们不能用我们实现替换他。所以让我们重构我们的代码，用一个*interface*代替它。
```golang
import "github.com/mediocregopher/radix.v2/redis"
type storager interface {
    Cmd(string, ...interface{}) *redis.Resp
}
type Handler struct {
    db storager
}
func (h *Handler) Ping() (string, error) {
    res := h.db.Cmd("INCR", "ping:count")
    if res.Err != nil {
        return "", res.Err
    }
    return "pong", nil
}
```
现在我们有一个`storager`的*interface*，这个*interface*定义了我们访问Redis的入参和出参。
再让我们看我们需要怎么做这个单元测试
```golang
import (
    "errors"
    "testing"
    "github.com/mediocregopher/radix.v2/redis"
    "github.com/stretchr/testify/assert"
)
func TestPing(t *testing.T) {
    sampleErr := errors.New("sample error")
    tests := map[string]struct {
        storageErr error
        response   string
        err        error
    }{
        "successful": {
            storageErr: nil,
            response:   "pong",
            err:        nil,
        },
        "with db error": {
            storageErr: sampleErr,
            response:   "",
            err:        sampleErr,
        },
    }
    for name, test := range tests {
        t.Logf("Running test case: %s", name)
        storage := &mockStorager{}
        storage.
            On("Cmd", "INCR", []interface{}{"ping:count"}).
            Return(&redis.Resp{
                Err: test.storageErr,
            }).
            Once()
        h := &Handler{
            db: storage,
        }
        response, err := h.Ping()
        assert.Equal(t, test.err, err)
        assert.Equal(t, test.response, response)
        storage.AssertExpectations(t)
    }
}
```
让我们一步一步的看
+ 首先，我设置了在我的map中设置了两种测试情况，第一个测试数据库不返回错误，第二个返回错误。
+ 我定义了一个`storage`变量，类型为`*mockStorager`，在接下来我会解释为什么会这么做。同时可以注意到我定义了输入的参数和对应的返回值。
+ 然后我验证了方法的返回值
+ `storage.AssertExpectations(t)`判断所有通过`storage`mock的函数返回值调用次数是否正确。在这个这段代码中`Cmd("INCR", "ping:count")`被调用，并且只被调用一次。

现在，`*mockStorager`是我通过[mockery](https://github.com/vektra/mockery)产生出的一个struct，（mockery是一个自动生成mock struct的工具，如果你没有用过这个，请仔细阅读）。

它可以基于任何一个`interface`生成一个可以使用的mock struct，命令如下：

```
mockery -name storager -inpkg .
```

现在我可以对`Ping`方法做单元测试。我们通过mock传入参数和返回值，可以不用依赖一个真正的数据库。

通过[mockery](https://github.com/vektra/mockery)生成的mocked interface类似于下面示例代码。示例代码是依赖于[testify/mock](https://github.com/stretchr/testify/tree/master/mock)通过实现接口完成的mock操作。`mockery`只是用来生成这些代码
```golang
import mock "github.com/stretchr/testify/mock"
import redis "github.com/mediocregopher/radix.v2/redis"
// mockStorager is an autogenerated mock type for the storager type
type mockStorager struct {
    mock.Mock
}
// Cmd provides a mock function with given fields: _a0, _a1
func (_m *mockStorager) Cmd(_a0 string, _a1 ...interface{}) *redis.Resp {
    ret := _m.Called(_a0, _a1)
    var r0 *redis.Resp
    if rf, ok := ret.Get(0).(func(string, ...interface{}) *redis.Resp); ok {
        r0 = rf(_a0, _a1...)
    } else {
        if ret.Get(0) != nil {
            r0 = ret.Get(0).(*redis.Resp)
        }
    }
    return r0
}
var _ storager = (*mockStorager)(nil)
```

### 关于testify/mock更多用法
你可以通过mock的对象做很多的有趣的事。在我们上面测试用例中我们值使用了`mock.On(...).Return(...).Once()`，但实际上你可以定义这次单元测试确切的调用次数。

更多关于`stretchr/testify/mock`的使用细节可以在[文档页面](https://godoc.org/github.com/stretchr/testify/mock)。

## 总结
这篇博客有两个主要的内容，我概括一下：

1. 通过`interface`注入你的依赖，这样单元测试可以变得更加简单（smoother）。
2. 我们可以使用比较有影响力的社区提供的框架例如`mockery`和`stretchr/testify/mock`，这样可以减轻我们的负担，让我们精力集中在我们自己的业务代码中。
